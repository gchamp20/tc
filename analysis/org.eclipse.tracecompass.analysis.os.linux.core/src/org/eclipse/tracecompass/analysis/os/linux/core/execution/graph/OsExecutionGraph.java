/*******************************************************************************
 * Copyright (c) 2015 École Polytechnique de Montréal
 *
 * All rights reserved. This program and the accompanying materials are
 * made available under the terms of the Eclipse Public License v1.0 which
 * accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *******************************************************************************/

package org.eclipse.tracecompass.analysis.os.linux.core.execution.graph;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.eclipse.core.runtime.IProgressMonitor;
import org.eclipse.jdt.annotation.Nullable;
import org.eclipse.tracecompass.analysis.graph.core.base.TmfGraph;
import org.eclipse.tracecompass.analysis.graph.core.building.ITmfGraphProvider;
import org.eclipse.tracecompass.analysis.graph.core.building.TmfGraphBuilderModule;
import org.eclipse.tracecompass.analysis.os.linux.core.realtime.KernelRealTimePatternRequest;
import org.eclipse.tracecompass.analysis.os.linux.core.realtime.RealTimePatternProvider;
import org.eclipse.tracecompass.analysis.os.linux.core.realtime.MANEPI.EventKey;
import org.eclipse.tracecompass.internal.analysis.graph.core.Activator;
import org.eclipse.tracecompass.tmf.core.event.ITmfEvent;
import org.eclipse.tracecompass.tmf.core.event.TmfEvent;
import org.eclipse.tracecompass.tmf.core.request.ITmfEventRequest;
import org.eclipse.tracecompass.tmf.core.request.TmfEventRequest;
import org.eclipse.tracecompass.tmf.core.timestamp.TmfTimeRange;
import org.eclipse.tracecompass.tmf.core.trace.ITmfTrace;
import org.eclipse.tracecompass.tmf.core.util.Pair;

/**
 * Graph building module for the lttng kernel execution graph
 *
 * @author Francis Giraldeau
 * @author Geneviève Bastien
 * @since 2.4
 */
public class OsExecutionGraph extends TmfGraphBuilderModule {

    private @Nullable TmfGraph fGraph;
    private @Nullable ITmfEventRequest fRequest;
    private @Nullable ITmfEventRequest fPatRequest;

    private @Nullable Map<Integer, List<Pair<List<EventKey>, List<Pair<Long, Long>>>>> fPatternsMap;

    /**
     * Gets the graph generated by the analysis
     *
     * @return The generated graph
     */
    @Override
    public @Nullable TmfGraph getGraph() {
        return fGraph;
    }

    @Override
    public @Nullable Pair<List<EventKey>, List<Pair<Long, Long>>> getPattern(Integer tid) {
        if (fPatternsMap != null) {
            List<Pair<List<EventKey>, List<Pair<Long, Long>>>> patterns = fPatternsMap.getOrDefault(tid,
                    new ArrayList<>());
            if (patterns.size() > 0) {
                return patterns.get(0);
            }
        }
        return null;
    }

    /**
     * Analysis id of this module
     */
    public static final String ANALYSIS_ID = "org.eclipse.tracecompass.analysis.os.linux.execgraph"; //$NON-NLS-1$

    @Override
    public boolean canExecute(ITmfTrace trace) {
        /**
         * TODO: Trace must have at least sched_switches and sched_wakeups
         * enabled
         */
        return true;
    }

    @Override
    protected ITmfGraphProvider getGraphProvider() {
        ITmfTrace trace = getTrace();
        if (trace == null) {
            throw new NullPointerException();
        }
        return new OsExecutionGraphProvider(trace);
    }

    /**
     * @return
     *      A new pattern provider
     * @since 3.1
     */
    protected RealTimePatternProvider getPatternProvider() {
        ITmfTrace trace = getTrace();
        if (trace == null) {
            throw new NullPointerException();
        }
        return new RealTimePatternProvider(trace);
    }

    @Override
    protected boolean executeAnalysis(final IProgressMonitor monitor) {
        if (fGraph == null) {
            final ITmfGraphProvider provider = getGraphProvider();

            final RealTimePatternProvider patProvider = getPatternProvider();
            /*
             * TODO: This will eventually support multiple backends so we can
             * save the graph on disk, like the state system, but for now, it is
             * just in memory
             */

            createGraph(provider, patProvider);

        }
        return !monitor.isCanceled();
    }

    @Override
    protected String getFullHelpText() {
        return super.getFullHelpText();
    }

    @Override
    protected String getShortHelpText(ITmfTrace trace) {
        return super.getShortHelpText(trace);
    }

    @Override
    protected String getTraceCannotExecuteHelpText(ITmfTrace trace) {
        return "The trace must have events 'sched_switch' and 'sched_wakeup' enabled"; //$NON-NLS-1$
    }

    // ------------------------------------------------------------------------
    // Graph creation methods
    // ------------------------------------------------------------------------

    private void createGraph(ITmfGraphProvider provider, RealTimePatternProvider patProvider) {

        fGraph = new TmfGraph();
        provider.assignTargetGraph(fGraph);

        fPatternsMap = new HashMap<>();
        patProvider.assignTargetMap(fPatternsMap);

        build(provider, patProvider);

    }

    private void build(ITmfGraphProvider provider, RealTimePatternProvider patProvider) {
        /* Cancel any previous request */
        ITmfEventRequest request = fRequest;
        ITmfEventRequest patRequest = fPatRequest;
        if ((request != null) && (!request.isCompleted())) {
            request.cancel();
        }

        if ((patRequest != null) && (!patRequest.isCompleted())) {
            patRequest.cancel();
        }

        try {
            request = new TmfGraphBuildRequest(provider);
            fRequest = request;
            provider.getTrace().sendRequest(request);

            patRequest = new KernelRealTimePatternRequest(patProvider);

            request.waitForCompletion();
            patRequest.waitForCompletion();
        } catch (InterruptedException e) {
            Activator.getInstance().logError("Request interrupted", e); //$NON-NLS-1$
        }
    }

    private static class TmfGraphBuildRequest extends TmfEventRequest {

        private final ITmfGraphProvider fProvider;

        /**
         * Constructor
         *
         * @param provider
         *            The graph provider
         */
        public TmfGraphBuildRequest(ITmfGraphProvider provider) {
            super(TmfEvent.class,
                    TmfTimeRange.ETERNITY,
                    0,
                    ITmfEventRequest.ALL_DATA,
                    ITmfEventRequest.ExecutionType.BACKGROUND);

            fProvider = provider;
        }

        @Override
        public void handleData(final ITmfEvent event) {
            super.handleData(event);
            fProvider.processEvent(event);
        }

        @Override
        public synchronized void done() {
            super.done();
            fProvider.done();
        }

        @Override
        public void handleCancel() {
            fProvider.handleCancel();
            super.handleCancel();
        }

    }
}
